JOINS:
======
EQUI JOIN / INNER JOIN:
=====================
EX:
WAQ TO RETRIEVAL STUDENT AND THEIR CORRESPONDING COURSE DETAILS?
NON-ANSI:
=========
SELECT * FROM STUDENT,COURSE WHERE STUDENT.CID=COURSE.CID;
			(OR)
SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID;

ANSI:
=====
SELECT * FROM STUDENT INNER JOIN COURSE ON STUDENT.CID=COURSE.CID;
			(OR)
SELECT * FROM STUDENT S INNER JOIN COURSE C ON S.CID=C.CID;

RULE OF JOINS:
==============
 - A ROW IN A TABLE IS COMPARING WITH ALL ROWS OF ANOTHER TABLE.

EX:
WAQ TO RETRIEVAL STUDENT,COURSE DETAILS WHO ARE SELECTED "ORACLE" COURSE?
ANSI:
SQL> SELECT STID,SNAME,CNAME FROM STUDENT S INNER JOIN COURSE C
  2  ON S.CID=C.CID AND CNAME='ORACLE';

NON-ANSI:
SQL> SELECT STID,SNAME,CNAME FROM STUDENT S , COURSE C
  2   WHERE S.CID=C.CID AND CNAME='ORACLE';

EX:
WAQ TO DISPLAY EMPLOYEES WHO ARE WORKING IN CHICAGO LOCATION?
ANSI:
SQL> SELECT ENAME,E.DEPTNO,D.DEPTNO,LOC FROM EMP E INNER JOIN
  2  DEPT D ON E.DEPTNO=D.DEPTNO AND LOC='CHICAGO';

NON-ANSI:
SQL> SELECT ENAME,E.DEPTNO,D.DEPTNO,LOC FROM EMP E ,
  2  DEPT D  WHERE E.DEPTNO=D.DEPTNO AND LOC='CHICAGO';

EX:
WAQ TO DISPLAY SUM OF SALARY OF EACH DEPARTMENT?
ANSI:
SQL> SELECT DNAME,SUM(SAL) FROM EMP E INNER JOIN DEPT D
  2  ON E.DEPTNO=D.DEPTNO GROUP BY DNAME;

NON-ANSI:
SQL> SELECT DNAME,SUM(SAL) FROM EMP E , DEPT D
  2  WHERE E.DEPTNO=D.DEPTNO GROUP BY DNAME;

DNAME            	SUM(SAL)
-------------- 		----------
RESEARCH            	10875
SALES                	9400
ACCOUNTING          8750

EX:
WAQ TO DISPLAY DEPARTMENTS IN WHICH DEPARTMENT SUM OF SALARY IS MORE THAN 
10000?
ANSI:
SQL> SELECT DNAME,SUM(SAL) FROM EMP E INNER JOIN DEPT D
     ON E.DEPTNO=D.DEPTNO GROUP BY DNAME HAVING SUM(SAL)>10000;

NON-ANSI:
SQL> SELECT DNAME,SUM(SAL) FROM EMP E , DEPT D
  2  WHERE E.DEPTNO=D.DEPTNO GROUP BY DNAME HAVING SUM(SAL)>10000;

DNAME            	SUM(SAL)
-------------- 		----------
RESEARCH              10875

OUTER JOINS:
============
	- THESE OUTER JOINS ARE USED TO RETRIEVAL MATCHING AND ALSO 
UNMATCHING ROWS FROM A TABLE.
	- THESE ARE 3 TYPES.

i) LEFT OUTER JOIN:
==================
	- MATCHING ROWS FROM BOTH TABLES BUT UNMATCHING ROWS FROM LEFT
SIDE TABLE ONLY.

ANSI:
=====
SQL> SELECT * FROM STUDENT S LEFT OUTER JOIN COURSE C ON S.CID=C.CID;

NON-ANSI:
=========
	- WHEN WE WRITE OUTER JOINS STATEMENTS IN NON-ANSI FORMAT THEN
WE SHOULD USE A JOIN OPERATOR IS (+).

SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID(+);

ii) RIGHT OUTER JOIN:
==================
	- MATCHING ROWS FROM BOTH TABLES BUT UNMATCHING ROWS FROM RIGHT
SIDE TABLE ONLY.

ANSI:
SQL> SELECT * FROM STUDENT S RIGHT OUTER JOIN COURSE C ON S.CID=C.CID;

NON-ANSI:
SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID(+)=C.CID;

iii) FULL OUTER JOIN:
===================
	- IT IS COMBINATION OF LEFT OUTER AND RIGHT OUTER.
	- MATCHING & UNMATCHING ROWS FROM BOTH TABLES.

ANSI:
SQL> SELECT * FROM STUDENT S FULL OUTER JOIN COURSE C ON S.CID=C.CID;

NON-ANSI:
SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID(+)=C.CID(+) ;                                   
ERROR at line 1:
ORA-01468: a predicate may reference only one outer-joined table

SOLUTION:
SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID(+)
  2  UNION
  3  SELECT * FROM STUDENT S,COURSE C WHERE S.CID(+)=C.CID;





































			











		
		
