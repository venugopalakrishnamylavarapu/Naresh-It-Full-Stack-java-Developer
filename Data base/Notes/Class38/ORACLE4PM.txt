SEQUENCE:
==========
	- IT IS A DB OBJECT WHICH IS USED TO GENERATE SEQUENCE NUMBERS 
ON A PARTICULAR COLUMN AUTOMATICALLY.
	- IT WILL PROVIDE  "AUTO INCREMENTAL VALUE" FACILITY ON A TABLE.

SYNTAX:
========
CREATE SEQUENCE <SEQUENCE NAME>
[START WITH n]
[MINVALUE n]
[INCREMENT BY n]
[MAXVALUE n]
[NO CYCLE / CYCLE]
[NO CACHE / CACHE n];

START WITH n:
=============
	- IT SPECIFY THE STARTING VALUE OF A SEQUENCE.
	- "n" ---------- NUMBER
MINVALUE n:
===========
	- IT SHOWS MINIMUM VALUE IN THE SEQUENCE.
	- "n" --------- NUMBER
INCREMENT BY n:
===============
	- IT SPECIFY INCRMENTAL VALUE IN BETWEEN SEQUENCE NUMBERS.
	- "n" --------- NUMBER
MAXVALUE n:
===========
	- IT SHOWS THE MAXIMUM VALUE IN THE SEQUENCE.
	- "n" --------- NUMBER
NO CYCLE:
=========
	- IT DEFAULT ATTRIBUTE OF SEQUENCE OBJECT.
	- WHEN WE CREATED A SEQUENCE WITH "NO CYCLE" ATTRIBUTE THEN 
THE SET OF SEQUENCE NUMBERS ARE NOT REPEATED.

	EX:
		START WITH 1
		MINVALUE 1
		INCREMENT BY 1
		MAXVALUE 3;

	OUTPUT:
	========
	1
	2
	3 ------- ONE CYCLE COMPLETED.

CYCLE:
======
	- WHEN WE CREATED A SEQUENCE WITH "CYCLE" ATTRIBUTE THEN THE SET
OF SEQUENCE NUMBERS ARE REPEATED AGAIN AND AGAIN.
	
	EX:
	
		START WITH 1
		MINVALUE 1
		INCREMENT BY 1
		MAXVALUE 3
		CYCLE;

	OUTPUT:
	========
	1
	2
	3 
	1
	2
	3
	1
	2
	3

NO CACHE:
=========
	- IT IS DEFAULT ATTRIBUTE OF SEQUENCE OBJECT.
	- CACHE IS NOTHING BUT TEMPORARY MEMORY.
	- WHEN WE CREATED A SEQUENCE OBJECT WITHOUT "CACHE" THEN THE 
SET SEQUENCE NUMBERS ARE SAVED IN DATABASE MEMORY DIRECTLY.SO THAT 
WHENEVER A USER WANT ACCESS DATA FROM A TABLE BASED ON SEQUENCE NUMBER
THEN EVERY REQUEST WILL GO TO DATABASE TO FIND A ROW AND RETURN TO 
A USER APPLICATION THIS MAY BE INCRESE THE BURDON ON DATABASE AND REDUCE 
THE PERFORMANCE OF DATABASE.

CACHE n:
========
	WHEN WE CREATED A SEQUENCE OBJECT WITH "CACHE" THEN THE 
SET SEQUENCE NUMBERS ARE SAVED IN DATABASE MEMORY AND COPY DATA IS SAVED IN CACHE MEMORY.SO THAT WHENEVER A USER WANT ACCESS DATA FROM A TABLE BASED ON SEQUENCE NUMBER THEN EVERY USER REQUEST WILL GO TO CACHE MEMORY INSTEAD OF DATABASE.TO FIND A ROW IN CACHE AND RETURN TO 
A USER APPLICATION THIS MAY BE REDUCE THE BURDON ON DATABASE AND IMPROVE
THE PERFORMANCE OF DATABASE.HERE "n" THE SIZE CACH FILE. MINIMUM FILE SIZE 
IS 2KB AND MAXIMUM IS 2O KB.

NOTE:
======
	WHEN WE WORK ON SEQUENCE THEN WE USE THE FOLLOWING PSEUDO COLUMNS ARE,
	i) NEXTVAL : TO GENERATE THE NEXT BY NEXT SEQUECNE NUMBER.
	ii) CURRVAL : TO SHOWS THE CURRENT VALUE  OF SEQUENCE.

	SNO
	=====
	1
	2
	3 ---------- NEXTVAL : 4	CURRVAL =3

EX1:
SQL> CREATE SEQUENCE SQ1
  2  START WITH 1
  3  MINVALUE 1
  4  INCREMENT BY 1
  5  MAXVALUE 3;
Sequence created.

TESTING:
SQL> CREATE TABLE TEST1(SNO INT,NAME VARCHAR2(10));

SQL> INSERT INTO TEST1 VALUES(SQ1.NEXTVAL,'&NAME');
Enter value for name: A
/
Enter value for name: B
/
Enter value for name: C
/
Enter value for name: D
ERROR at line 1:
ORA-08004: sequence SQ1.NEXTVAL exceeds MAXVALUE and cannot be instantiated

SQL> SELECT * FROM TEST1;

       SNO NAME
---------- ----------
         1 A
         2 B
         3 C

ALTERING A SEQUENCE:
======================
SYNTAX:
=======
ALTER SEQUENCE <SEQUENCE NAME> <ATTRIBUTE NAME> n;

EX:
SQL> ALTER SEQUENCE SQ1 MAXVALUE 5;
Sequence altered.

SQL> INSERT INTO TEST1 VALUES(SQ1.NEXTVAL,'&NAME');
Enter value for name: D
/
Enter value for name: E

SQL> SELECT * FROM TEST1;

       SNO NAME
---------- ----------
         1 A
         2 B
         3 C
         4 D
         5 E

EX2:
SQL> CREATE SEQUENCE SQ2
  2  START WITH 1
  3  MINVALUE 1
  4  INCREMENT BY 1
  5  MAXVALUE 3
  6  CYCLE
  7  CACHE 2;

TESTING:
SQL> CREATE TABLE TEST2(SNO INT,NAME VARCHAR2(10));
SQL> INSERT INTO TEST2 VALUES(SQ2.NEXTVAL,'&NAME');
Enter value for name: A
/
.....................................
/
......................................

EX3:
SQL> CREATE SEQUENCE SQ3
  2  START WITH 3
  3  MINVALUE 1
  4  INCREMENT BY 1
  5  MAXVALUE 5
  6  CYCLE
  7  CACHE 2;

TESTING
SQL> CREATE TABLE TEST3(SNO INT,NAME VARCHAR2(10));

SQL> INSERT INTO TEST3 VALUES(SQ3.NEXTVAL,'&NAME');
Enter value for name: A
/
...................................
/
...................................

NOTE:
======
	- TO VIEW ALL SEQUENCE OBJECTS IN ORACLE DB THEN WE USE A DATADICTIONARY "USER_SEQUENCES".

EX:
SQL> DESC USER_SEQUENCES;
SQL> SELECT SEQUENCE_NAME FROM USER_SEQUENCES;

HOW TO DROP A SEQUENCE:
=========================
SYNTAX:
========
DROP SEQUENCE <SEQUENCE NAME>;

EX:
DROP SEQUENCE SQ1;
===========================================================================
PARTITION TABLE:
================
	I) RANGE PARTITION
	II) LIST PARTITION
	III) HASH PARTITION

I) RANGE PARTITION:
===================
	- CREATED A PARTITION TABLE BASED ON A PARTICULAR RANGE VALUE.

SYNTAX:
=======
CREATE TABLE <TABLE NAME>(<COLUMN NAME1> <DT>[SIZE],..................................)
PARTITION BY RANGE(KEY COLUMN NAME)
(PARTITION <PARTITION NAME1> VALUES LESS THAN(VALUE),
PARTITION <PARTITION NAME2> VALUES LESS THAN(VALUE),
..................................................................................................
);

EX:
SQL> CREATE TABLE TEST41(EID INT,ENAME VARCHAR2(10),
  2  SAL NUMBER)PARTITION BY RANGE(SAL)
  3  (PARTITION P1 VALUES LESS THAN(500),
  4  PARTITION P2 VALUES LESS THAN(2000),
  5  PARTITION P3 VALUES LESS THAN(2500)
  6  );
Table created.

SQL> INSERT INTO TEST41 VALUES(1,'SMITH',1500);
SQL> INSERT INTO TEST41 VALUES(2,'ALLEN',450);

HOW TO CALL A PARTICULAR PARTITION:
====================================
SYNTAX:
========
SELECT * FROM <TN> PARTITION (PARTITION NAME);

EX:
SELECT * FROM TEST41 PARTITION(P1);

LIST PARTITION:
===============
	- CREATED A PARTITION TABLE BASED ON LIST OF VALUES.

SYNTAX:
=======
CREATE TABLE <TABLE NAME>(<COLUMN NAME1> <DT>[SIZE],..................................)
PARTITION BY LIST(KEY COLUMN NAME)
(PARTITION <PARTITION NAME1> VALUES (V1,V2,V3,......),
PARTITION <PARTITION NAME2> VALUES (V1,V2,V3,......),
......................................................
PARTITION OTHERS VALUES(DEFAULT));

EX:
SQL> CREATE TABLE TEST2(CID INT,CNAME VARCHAR2(10))
  2  PARTITION BY LIST(CNAME)
  3  (PARTITION P1 VALUES('ORACLE','MYSQL','MSSQL'),
  4  PARTITION P2 VALUES('JAVA','PHP','.NET'),
  5  PARTITION OTHERS VALUES(DEFAULT));
Table created.

SQL> INSERT INTO TEST2 VALUES(1,'C');
SQL> INSERT INTO TEST2 VALUES(2,'ORACLE');
..........................................;

CALLING A PARTITION:
====================
SQL> SELECT * FROM TEST2 PARTITION(P1);

HASH PARTITION:
===============
	- CREATED PARTITION TABLE BY SYSTEM BY DEFAULT.

SYNTAX:
=======
CREATE TABLE <TN>(<COL1> <DT>[SIZE],..............)
PARTITION BY HASH(KEY COLUMN NAME) PARTITIONS <number>;

EX:
SQL> CREATE TABLE TEST3(ENAME VARCHAR2(10),SAL NUMBER(10))
  2  PARTITION BY HASH(SAL) PARTITIONS 5;

NOTE:
=====
	- TO VIEW ALL PARTITIONS OF A PARTICULAR TABLE IN ORACLE DB
THEN USE A DATADICTIONARY IS "USER_TAB_PARTITIONS".

EX:
SQL> DESC USER_TAB_PARTITIONS;
SQL> SELECT PARTITION_NAME FROM USER_TAB_PARTITIONS
     WHERE TABLE_NAME='TEST3';

HOW TO ADD A NEW PARTITION TO AN EXISTING TABLE:
================================================
SYNTAX FOR LIST PARTITION:
===========================
ALTER TABLE <TN> ADD PARTITION <PARTITION NAME> VALUES(V1,V2,....);

SYNTAX FOR RANGE PARTITION:
============================
ALTER TABLE <TN> ADD PARTITION <PARTITION NAME> VALUES
LESS THAN(VALUE);

EX FOR LIST PARTITION:
=======================
SQL>ALTER TABLE TEST2 ADD PARTITION P3VALUES('PYTHON','SAP');

ERROR at line 1:
ORA-14323: cannot add partition when DEFAULT partition exists

	- TO ADD ANY NEW PARTITION TO LIST PARTITION TABLE THEN WE 
REMOVE "OTHERS" PARTITION THEN ONLY WE CAN ADD A NEW PARTITION.

SYNTAX TO DROP A PARTITION FROM AN EXISTING TABLE:
==================================================
ALTER TABLE <TN> DROP PARTITION <PARTITION NAME>;

EX:
SQL> ALTER TABLE TEST2 DROP PARTITION OTHERS;
SQL> ALTER TABLE TEST2 ADD PARTITION P3 VALUES('PYTHON','SAP');

NOTE:
=====
	- TO CHECK A TABLE IS PARTITIONED OR NOT THEN WE USE
A DATADICTIONARY IS "USER_TABLES".

EX:
SQL> DESC USER_TABLES;
SQL> SELECT  PARTITIONED FROM USER_TABLES
     WHERE TABLE_NAME='DEPT';

PAR
---
NO

SQL> SELECT  PARTITIONED FROM USER_TABLES
     WHERE TABLE_NAME='TEST2';

PAR
---
YES
==============================================================
LOCKS:
======
	- IT IS A TECHNIQUE TO PREVENT UNAUTHORIZED ACCESS OF OUR 
RESOURCE.
				1) ROW LEVEL LOCKING
				2) TABLE LEVEL LOCKING

1) ROW LEVEL LOCKING:
=====================
	i) SINGLE ROW LOCKING 
	ii) MULTIPLE ROWS LOCKING

i) SINGLE ROW LOCKING:
======================
	- IN THIS LEVEL WE CAN LOCK A SINGLE ROW.

EX:
	USER-1										USER-2
	=======										=======
SQL> CONN SYSTEM/TIGER					SQL> CONN MYDB4PM/MYDB4PM

SQL> UPDATE MYDB4PM.EMP SET 			SQL> UPDATE EMP SET 
SAL=1100 WHERE EMPNO=7369;				SAL=2200 WHERE EMPNO=7369;
[ ROW IS LOCKED ] 						[CANNOT PERFORM UPDATE 													- OPERATION ]

SQL> COMMIT / ROLLBACK;					SQL> 1 row updated.
[ FOR RELEASING LOCK ] 

ii) MULTIPLE ROWS LOCKING:
==========================
	- WHEN WE LOCK MULTIPLE ROWS THEN WE SHOULD USE 
"FOR UPDATE" CLAUSE IN SELECT QUERY.

EX:

	USER-1										USER-2
	=======										=======
SQL> CONN SYSTEM/TIGER					SQL> CONN MYDB4PM/MYDB4PM

SQL> SELECT * FROM MYDB4PM.EMP		SQL> UPDATE EMP SET 
WHERE DEPTNO=10 FOR UPDATE;			SAL=3300 WHERE DEPTNO=10;
[DEPTNO 10 ROWS ARE LOCKED]			[CANNOT PERFORM UPDATE]

SQL> COMMIT / ROLLBACK;					SQL> 3 rows updated.
[ FOR RELEASING LOCK ] 
















































	












































































































































