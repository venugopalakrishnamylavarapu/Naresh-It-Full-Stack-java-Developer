JOINS:
======
EQUI JOIN / INNER JOIN:
=====================
EX:
WAQ TO RETRIEVAL STUDENT AND THEIR CORRESPONDING COURSE DETAILS?
NON-ANSI:
=========
SELECT * FROM STUDENT,COURSE WHERE STUDENT.CID=COURSE.CID;
			(OR)
SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID;

ANSI:
=====
SELECT * FROM STUDENT INNER JOIN COURSE ON STUDENT.CID=COURSE.CID;
			(OR)
SELECT * FROM STUDENT S INNER JOIN COURSE C ON S.CID=C.CID;

RULE OF JOINS:
==============
 - A ROW IN A TABLE IS COMPARING WITH ALL ROWS OF ANOTHER TABLE.

EX:
WAQ TO RETRIEVAL STUDENT,COURSE DETAILS WHO ARE SELECTED "ORACLE" COURSE?
ANSI:
SQL> SELECT STID,SNAME,CNAME FROM STUDENT S INNER JOIN COURSE C
  2  ON S.CID=C.CID AND CNAME='ORACLE';

NON-ANSI:
SQL> SELECT STID,SNAME,CNAME FROM STUDENT S , COURSE C
  2   WHERE S.CID=C.CID AND CNAME='ORACLE';

EX:
WAQ TO DISPLAY EMPLOYEES WHO ARE WORKING IN CHICAGO LOCATION?
ANSI:
SQL> SELECT ENAME,E.DEPTNO,D.DEPTNO,LOC FROM EMP E INNER JOIN
  2  DEPT D ON E.DEPTNO=D.DEPTNO AND LOC='CHICAGO';

NON-ANSI:
SQL> SELECT ENAME,E.DEPTNO,D.DEPTNO,LOC FROM EMP E ,
  2  DEPT D  WHERE E.DEPTNO=D.DEPTNO AND LOC='CHICAGO';

EX:
WAQ TO DISPLAY SUM OF SALARY OF EACH DEPARTMENT?
ANSI:
SQL> SELECT DNAME,SUM(SAL) FROM EMP E INNER JOIN DEPT D
  2  ON E.DEPTNO=D.DEPTNO GROUP BY DNAME;

NON-ANSI:
SQL> SELECT DNAME,SUM(SAL) FROM EMP E , DEPT D
  2  WHERE E.DEPTNO=D.DEPTNO GROUP BY DNAME;

DNAME            	SUM(SAL)
-------------- 		----------
RESEARCH            	10875
SALES                	9400
ACCOUNTING          8750

EX:
WAQ TO DISPLAY DEPARTMENTS IN WHICH DEPARTMENT SUM OF SALARY IS MORE THAN 
10000?
ANSI:
SQL> SELECT DNAME,SUM(SAL) FROM EMP E INNER JOIN DEPT D
     ON E.DEPTNO=D.DEPTNO GROUP BY DNAME HAVING SUM(SAL)>10000;

NON-ANSI:
SQL> SELECT DNAME,SUM(SAL) FROM EMP E , DEPT D
  2  WHERE E.DEPTNO=D.DEPTNO GROUP BY DNAME HAVING SUM(SAL)>10000;

DNAME            	SUM(SAL)
-------------- 		----------
RESEARCH              10875

OUTER JOINS:
============
	- THESE OUTER JOINS ARE USED TO RETRIEVAL MATCHING AND ALSO 
UNMATCHING ROWS FROM A TABLE.
	- THESE ARE 3 TYPES.

i) LEFT OUTER JOIN:
==================
	- MATCHING ROWS FROM BOTH TABLES BUT UNMATCHING ROWS FROM LEFT
SIDE TABLE ONLY.

ANSI:
=====
SQL> SELECT * FROM STUDENT S LEFT OUTER JOIN COURSE C ON S.CID=C.CID;

NON-ANSI:
=========
	- WHEN WE WRITE OUTER JOINS STATEMENTS IN NON-ANSI FORMAT THEN
WE SHOULD USE A JOIN OPERATOR IS (+).

SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID(+);

ii) RIGHT OUTER JOIN:
==================
	- MATCHING ROWS FROM BOTH TABLES BUT UNMATCHING ROWS FROM RIGHT
SIDE TABLE ONLY.

ANSI:
SQL> SELECT * FROM STUDENT S RIGHT OUTER JOIN COURSE C ON S.CID=C.CID;

NON-ANSI:
SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID(+)=C.CID;

iii) FULL OUTER JOIN:
===================
	- IT IS COMBINATION OF LEFT OUTER AND RIGHT OUTER.
	- MATCHING & UNMATCHING ROWS FROM BOTH TABLES.

ANSI:
SQL> SELECT * FROM STUDENT S FULL OUTER JOIN COURSE C ON S.CID=C.CID;

ANON-ANSI:
SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID(+)=C.CID(+) ;                                   
ERROR at line 1:
ORA-01468: a predicate may reference only one outer-joined table

SOLUTION:
SQL> SELECT * FROM STUDENT S,COURSE C WHERE S.CID=C.CID(+)
  2  UNION
  3  SELECT * FROM STUDENT S,COURSE C WHERE S.CID(+)=C.CID;

NON-EQUI JOIN:
==============
	- RETRIEVAL DATA FROM MULTIPLE TABLES BASED ON ANY OPERATOR
EXCEPT AN "=" OPERATOR.
	- IN THIS JOIN WE CAN USE " < , > , <= , >= , != , BETWEEN,AND,.......etc".

EX:
NON-ANSI:
SQL> SELECT * FROM TEST1 T1,TEST2 T2 WHERE T1.SNO > T2.SNO;

ANSI:
SQL> SELECT * FROM TEST1 T1 JOIN TEST2 T2 ON T1.SNO > T2.SNO;

EX:
WAQ TO DISPLAY EMPLOYEES WHOSE SALARY IS BETWEEN LOW SALARY AND HIGH SALARY?

NON-ANSI:
SQL> SELECT ENAME,SAL,LOSAL,HISAL FROM EMP,SALGRADE
  2  WHERE SAL BETWEEN LOSAL AND HISAL;
		(OR)
SQL> SELECT ENAME,SAL,LOSAL,HISAL FROM EMP,SALGRADE
  2  WHERE (SAL>=LOSAL) AND (SAL<=HISAL);

ANSI:
SQL> SELECT ENAME,SAL,LOSAL,HISAL FROM EMP JOIN SALGRADE
  2  ON SAL BETWEEN LOSAL AND HISAL;
		(OR)
SQL> SELECT ENAME,SAL,LOSAL,HISAL FROM EMP JOIN SALGRADE
  2  ON (SAL>=LOSAL) AND (SAL<=HISAL);

CROSS JOIN:
===========
	- IT IS DEFAULT JOIN. WHICH IS USED TO JOIN TWO OR MORE THAN TWO 
TABLES WITHOUT ANY CONDITION.
	- IN CROSS JOIN, EACH ROW OF THE FIRST TABLE IS COMPARING WITH 
EACH ROW OF THE SECOND TABLE.FOR EXAMPLE A TABLE IS HAVING (M) NO.OF ROWS
AND THE SECOND TABLE IS HAVING (N) NO.OF ROWS THEN THE RESULT IS (M X N) ROWS.

EX:
NON-ANSI:
SQL> SELECT * FROM STUDENT CROSS JOIN COURSE;

ANSI:
SQL> SELECT * FROM STUDENT CROSS JOIN COURSE;

EX:
SQL> SELECT * FROM ITEMS1;

       SNO 	INAME           	PRICE
---------- 	---------- 		----------
         1 	PIZZA             	150
         2 	BURGER             	85

SQL> SELECT * FROM ITEMS2;

       SNO 	INAME           	PRICE
---------- 	---------- 		----------
       101 	PEPSI              	25
       102 	COCACOLA           	20

ANSI:
SQL> SELECT I1.INAME,I1.PRICE,I2.INAME,I2.PRICE,
  2  I1.PRICE+I2.PRICE TOTAL_AMOUNT FROM
  3  ITEMS1 I1 CROSS JOIN ITEMS2 I2;

NON-ANSI:
SQL> SELECT I1.INAME,I1.PRICE,I2.INAME,I2.PRICE,
  2  I1.PRICE+I2.PRICE TOTAL_AMOUNT FROM
  3  ITEMS1 I1,ITEMS2 I2;

INAME           	PRICE 	INAME           	PRICE 	TOTAL_AMOUNT
---------- 		---------- 	---------- 		---------- 	------------
PIZZA             	150 	PEPSI              	25          	175

NATURAL JOIN:
==============
	- IT IS SIMILAR TO EQUI JOIN.BECAUSE NATURAL JOIN IS ALSO RETRIEVING 
MATCHING ROWS BASED ON AN "=" OPERATOR JUST LIKE EQUI JOIN.


	NATURAL JOIN 			EQUI JOIN
	=============			==========
- COMMON COLUMN NAME IS 		- OPTIONAL 
MANDATORY.

- JOINING CONDITION IS 			- JOINING CONDITION PREPARED BY 
PREPARED BY SYSTEM 			USER EXPLICITLY.
IMPLICITLY.

- TO AVOID DUPLICATE COLUMNS		- NOT AVOID DUPLICATE COLUMNS.

EX:
SQL> SELECT * FROM STUDENT S NATURAL JOIN COURSE C;

SELF JOIN:
==========
	- JOINING A TABLE BY ITSELF IS CALLED AS "SELF JOIN".
	- SELF JOIN CAN BE IMPLEMENTED BASED ON A SINGLE TABLE.
	- WHEN WE WANT TO USE SELF JOIN WE SHOULD CREATE ALIAS NAMES 
ON A TABLE.ONCE WE CREATE ALIAS NAME ON A TABLE INTERNALLY SYSTEM IS PPREPARING VIRTUAL TABLE COPY OF EACH ALIAS NAME.
	- WE CAN CREATE ANY NO.OF ALIAS NAMES ON A SINGLE TABLE BUT EACH 
ALIAS NAME SHOULD BE DIFFERENT.
	- WITHOUT ALIAS NAMES WE CANNOT IMPLEMENT SELF JOIN MECHANISM.

PURPOSE OF SELF JOIN:
=====================
	CASE-1. COMPARING A SINGLE COLUMN VALUES BY ITSELF WITH IN THE TABLE.
	CASE-2. COMPARING TWO DIFFERENT COLUMNS VALUES TO EACH OTHER WITH IN THE TABLE.

EX.ON CASE-1:
=============
WAQ TO DISPLAY EMPLOYEE WHO ARE WORKING IN SAME LOCATION THE EMPLOYEE 
"SMITH" IS ALSO WORKING?

SQL> SELECT * FROM TEST;

ENAME      LOC
---------- 	----------
SMITH      HYD
JONES     MUMBAI
WARD       HYD
MILLER    CHENNAI

SOLUTION:
==========
SQL> SELECT T1.ENAME,T1.LOC FROM TEST T1,TEST T2
         WHERE T1.LOC=T2.LOC AND T2.ENAME='SMITH';

ENAME      LOC
---------- 	----------
SMITH      HYD
WARD       HYD

EX:
WAQ TO DISPLAY EMPLOYEES WHOSE SALARY IS SAME AS THE EMPLOYEE "SCOTT" 
SALARY?
NON-ANSI:
========
SQL> SELECT E1.ENAME,E1.SAL FROM EMP E1,EMP E2
    WHERE E1.SAL=E2.SAL AND E2.ENAME='SCOTT';

ANSI:
=====
SQL> SELECT E1.ENAME,E1.SAL FROM EMP E1 JOIN EMP E2
    ON E1.SAL=E2.SAL AND E2.ENAME='SCOTT';

ENAME             	SAL
---------- 		----------
SCOTT            	3000
FORD             	3000

EX.ON CASE-2:
=============
WAQ TO DISPLAY MANAGERS AND THEIR EMPLOYEES?
SQL> SELECT M.ENAME MANAGERS,E.ENAME EMPLOYEES
  2  FROM EMP E,EMP M WHERE M.EMPNO=E.MGR;

EX:
WAQ TO DISPLAY EMPLOYEES WHO ARE JOINED BEFORE THEIR MANAGER?
SQL> SELECT E.ENAME EMPLOYEES,E.HIREDATE E_DOJ,
  2  M.ENAME MANAGER,M.HIREDATE M_DOJ FROM
  3  EMP E,EMP M WHERE M.EMPNO=E.MGR
  4  AND E.HIREDATE < M.HIREDATE;

EX:
WAQ TO DISPLAY EMPLOYEES WHOSE SALARY IS MORE THAN THEIR MANAGER SALARY?
SQL> SELECT E.ENAME EMPLOYEES,E.SAL E_SALARY,
  2  M.ENAME MANAGERS,M.SAL M_SALARY FROM
  3  EMP E,EMP M WHERE M.EMPNO=E.MGR
  4  AND E.SAL > M.SAL;


















	
		
	
























































































			











		
		
