DATAINTEGRITY:
==============
	- TO MAINTAIN ACCURATE AND CONSISTENCY DATA IN DB TABLES.
		1. DECLARATIVE INTEGRITY
			> CAN IMPLEMENTING BY USING "CONSTRAINTS"(SQL)
		2. PROCEDURAL INTEGRITY 
			> CAN IMPLEMENTING BY USING "TRIGGERS"(PL/SQL)

1. DECLARATIVE INTEGRITY:
=========================
	i) ENTITY INTEGRITY
	ii) REFERENCIAL INTEGRITY
	iii) DOMAIN INTEGRITY

i) ENTITY INTEGRITY:
==================
	- IT ENSURE THAT EACH ROW IN A TABLE SHOULD BE UNIQUE IDENTITY.
	- IT CAN BE IMPLEMENTED BY USING "UNIQUE , PRIMARY KEY" CONSTRAINTS.

ii) REFERENCIAL INTEGRITY:
=========================
	- TO MAKING RELATIONSHIPS BETWEEN TABLES.
	- BY USING "FOREIGN KEY" CONSTRAINT.

iii) DOMAIN INTEGRITY:
====================
	- TO CHECK VALUES WITH USER DEFINED CONDITION BEFORE ACCEPTING 
	INTO A COLUMN.
	- IT CAN BE IMPLEMENTED BY USING "CHECK,NOT NULL,DEFAULT" CONSTRAINTS.

CONSTRAINTS:
=============
	- ARE USED TO RESTRICTED / ENFORCE UNWANTED DATA FROM DB TABLES.
	- THESE ARE 6 TYPES,
		> UNIQUE
		> NOT NULL
		> CHECK
		> PRIMARY KEY
		> FOREIGN KEY / REFERENCES 
		> DEFAULT 
	- ALL DATABASES ARE SUPPORTING TWO TYPES OF METHODS TO DEFINED 
CONSTRAINTS ON A TABLE.

i) COLUMN LEVEL:
================
	- TO DEFINE A CONSTRAINT ON EACH COLUMN WISE.

SYNTAX:
=======
CREATE TABLE <TABLE NAME>
(
<COLUMN NAME1> <DATATYPE>[SIZE] <CONSTRAINT TYPE>,
<COLUMN NAME2> <DATATYPE>[SIZE] <CONSTRAINT TYPE>,
................................................................................................,
................................................................................................
);

ii) TABLE LEVEL:
==============
	- TO DEFINE A CONSTRAINT AFTER ALL COLUMNS ARE DESIGNED.
	i.e END OF THE TABLE.

SYNTAX:
=======
CREATE TABLE <TABLE NAME>
(
<COLUMN NAME1> <DATATYPE>[SIZE],
<COLUMN NAME2> <DATATYPE>[SIZE],
............................................................,
...........................................................,
<CONSTRAINT TYPE>(<COLUMN NAME1>,.........)
);

UNIQUE:
========
	- TO RESTRCITED DUPLICATE VALUES.
	- BUT ALLOWED "NULLS".
EX:
COLUMN LEVEL:
==============
SQL> CREATE TABLE TEST1
  2  (
  3  SNO INT UNIQUE,
  4  SNAME VARCHAR2(10) UNIQUE
  5  );

TESTING:
SQL> INSERT INTO TEST1 VALUES(1,'A');----------------ALLOWED
SQL> INSERT INTO TEST1 VALUES(1,'A');---------------NOT ALLOWED
SQL> INSERT INTO TEST1 VALUES(NULL,NULL);-----ALLOWED
SQL> INSERT INTO TEST1 VALUES(2,'B');-------ALLOWED

TABLE LEVEL:
============
SQL> CREATE TABLE TEST2
  2  (
  3  SNO INT,
  4  SNAME VARCHAR2(10),
  5  UNIQUE(SNO,SNAME) -----------------> COMPOSITE UNIQUE CONSTRAINT
  6  );

TESTING:
=========
SQL> INSERT INTO TEST2 VALUES(1,'A');------ALLOWED
SQL> INSERT INTO TEST2 VALUES(1,'A');------NOT ALLOWED
SQL> INSERT INTO TEST2 VALUES(2,'A');------ALLOWED

NOT NULL:
=========
	- TO RESTRICTED NULLS INTO A COLUMN.
	- IT CAN DEFINED AT COLUMN LEVEL ONLY.
	- BUT ALLOWED DULICATE VALUES.

EX:
SQL> CREATE TABLE TEST3(SNO INT NOT NULL,SNAME VARCHAR2(10) NOT NULL);

TESTING:
SQL> INSERT INTO TEST3 VALUES(1,'A');----------ALLOWED
SQL> INSERT INTO TEST3 VALUES(1,'A');---------ALLOWED
SQL> INSERT INTO TEST3 VALUES(NULL,NULL);----NOT ALLOWED

HOW TO DEFINED MULTIPLE CONSTRAINTS ON A COLUMN:
===================================================
EX:
SQL> CREATE TABLE TEST4(EID INT UNIQUE NOT NULL,
ENAME VARCHAR2(10) UNIQUE NOT NULL);

TESTING:
SQL> INSERT INTO TEST4 VALUES(101,'SMITH');----ALLOWED
SQL> INSERT INTO TEST4 VALUES(101,'SMITH');-----NO
SQL> INSERT INTO TEST4 VALUES(NULL,NULL);-----NO

CHECK:
=======
	- TO CHECK VALUES WITH USER DEFINED CONDITION ON A COLUMN.

EX:
COLUMN LEVEL:
===============
SQL> CREATE TABLE TEST5(ENAME VARCHAR2(10),SAL NUMBER(10) CHECK(SAL>10000));

TESTING:
SQL> INSERT INTO TEST5 VALUES('SMITH',8500);------NOT ALLOWED
SQL> INSERT INTO TEST5 VALUES('SMITH',12000);----ALLOWED

TABLE LEVEL:
============
SQL> CREATE TABLE TEST6(ENAME VARCHAR2(10),SAL NUMBER(10),
          CHECK(ENAME=LOWER(ENAME) AND SAL>=8000));

TESTING:
SQL> INSERT INTO TEST6 VALUES('ALLEN',10000);----NOT ALLOWED
SQL> INSERT INTO TEST6 VALUES('allen',7500);----NOT ALLOWED
SQL> INSERT INTO TEST6 VALUES('allen',10000);-----ALLOWED

PRIMARY KEY:
============
	- IT IS A COMBINATION OF UNIQUE AND NOT NULL.
	- IT NOT ALLOWED DUPLICATE VALUES AND NULLS.
	- A TABLE IS HAVING ONLY ONE PRIMARY KEY CONSTRAINT.

EX:
COLUMN LEVEL:
==============
SQL> CREATE TABLE PRODUCT(PCODE INT PRIMARY KEY,
          PNAME VARCHAR2(10));

TESTING:
SQL> INSERT INTO PRODUCT VALUES(1021,'C');--------ALLOWED
SQL> INSERT INTO PRODUCT VALUES(1021,'C++');------NO
SQL> INSERT INTO PRODUCT VALUES(NULL,'C++');------NO

TABLE LEVEL:
============
SQL> CREATE TABLE BRANCH(BCODE INT,
  2  BNAME VARCHAR2(10),
  3  BLOC VARCHAR2(10),
  4  PRIMARY KEY(BCODE,BNAME));---------COMPOSITE PRIMARY KEY CONSTRAINT

TESTING:
SQL> INSERT INTO BRANCH VALUES(1021,'SBI','SRNAGAR');------ALLOWED
SQL> INSERT INTO BRANCH VALUES(1021,'SBI','MADHAPUR');-----NO
SQL> INSERT INTO BRANCH VALUES(1022,'SBI','MADHAPUR');----ALLOWED

FOREIGN KEY(REFERENCES)
=========================
	- TO CREATE RELATIONSHIP BETWEEN TABLES.
	- BY USING RELATIONSHIP WE CAN TAKE REFERENCIAL(IDENTITY) DATA FROM 
ONE TABLE TO ANOTHER TABLE IN DATABASE.

BASIC RULES:
============
1. COMMON COLUMN NAME(OPTIONAL) IN BOTH TABLES.

2. COMMON COLUMN  DATATYPES MUST BE MATCH.(MANDATORY)

3. ONE TABLE SHOULD CONTAIN PRIMARY KEY AND ANOTHER TABLE SHOULD CONTAIN FOREIGN KEY BUT
PK AND FK COLUMN MUST BE COMMON COLUMN.

4. A PRIMARY KEY CONSTRAINT TABLE IS CALLED AS "PARENT" TABLE AND A FOREIGN KEY CONSTRAINT
TABLE IS CALLED AS "CHILD" TABLE.

5. A FOREIGN KEY COLUMN IS ALLOWED THE VALUES THOSE VALUES MUST BE IN PRIMARY KEY COLUMN.


	PARENT		CHILD
	TEST1		TEST2	
	======		======	
	SNO(PK)		SNO(FK)
	========		========
	1		1
	2		1
	3		2
			2
			3
			3
			3
			4----------ERROR
			NULL-----ALLOWED(ORPHAN)

6. BY DEFAULT FOREIGN KEY IS ALLOWED DUPLICATE AND NULLS.

EX:
SQL> CREATE TABLE DEPT1(DEPTNO INT PRIMARY KEY,DNAME VARCHAR2(10));--PARENT

SQL> INSERT INTO DEPT1 VALUES(10,'SALES');
SQL> INSERT INTO DEPT1 VALUES(20,'PRODUCTION');

SQL> CREATE TABLE EMP1(EID INT UNIQUE NOT NULL,
  2  ENAME VARCHAR2(10),DEPTNO INT REFERENCES
  3  DEPT1(DEPTNO));---CHILD

SQL> INSERT INTO EMP1 VALUES(1021,'SMITH',10);
SQL> INSERT INTO EMP1 VALUES(1022,'ALLEN',10);
SQL> INSERT INTO EMP1 VALUES(1023,'WARD',20);
.................................................................................;

NOTE:
=====
	- ONCE WE CREATED RELATIONSHIP BETWEEN TABLES THERE ARE TWO RULES
ARE COME INTO PICTURE.

RULE-1(INSERTION):
=================
	- WE CANNOT INSERT VALUES INTO FOREIGN KEY COLUMN IN CHILD TABLE 
THOSE VALUES ARE NOT EXISTING IN PRIMARY KEY COLUMN OF PARENT TABLE.

		NO PARENT = NO CHILD
EX:
SQL> INSERT INTO EMP1 VALUES(1025,'SCOTT',30);
ERROR at line 1:
ORA-02291: integrity constraint (MYDB4PM.SYS_C007550) violated - parent key not found

RULE-2(DELETION)
================
	- WE CANNOT DELETE A ROW FROM PARENT TABLE THOSE ROWS ARE HAVING 
THE CORRESPONDING CHILD ROWS IN CHILD TABLE WITHOUT ADDRESSING TO THE CHILD.

EX:
SQL> DELETE FROM DEPT1 WHERE DEPTNO=10
ERROR at line 1:
ORA-02292: integrity constraint (MYDB4PM.SYS_C007550) violated - child record found

HOW TO ADDRESS TO CHILD TABLE:
===============================
	> CASCADE RULES :
		1. ON DELETE CASCADE
		2. ON DELETE SET NULL

1. ON DELETE CASCADE:
======================
	- ONCE WE DELETE A ROW FROM PARENT TABLE THEN THE CORRESPONDING 
CHILD ROWS ARE ALSO DELETED FROM CHILD TABLE AUTOMATICALLY.

EX:
SQL> CREATE TABLE DEPT2(DEPTNO INT PRIMARY KEY,DNAME VARCHAR2(10));--PARENT

SQL> INSERT INTO DEPT2 VALUES(10,'SALES');
SQL> INSERT INTO DEPT2 VALUES(20,'PRODUCTION');

SQL> CREATE TABLE EMP2(EID INT UNIQUE NOT NULL,
    ENAME VARCHAR2(10),DEPTNO INT REFERENCES
    DEPT2(DEPTNO) ON DELETE CASCADE);---CHILD

SQL> INSERT INTO EMP2 VALUES(1021,'SMITH',10);
SQL> INSERT INTO EMP2 VALUES(1022,'ALLEN',10);
SQL> INSERT INTO EMP2 VALUES(1023,'WARD',20);

TESTING:
SQL> DELETE FROM DEPT2 WHERE DEPTNO=10;
1 row deleted.

2. ON DELETE SET NULL:
=====================
	- ONCE WE DELETE A ROW FROM PARENT TABLE THEN THE CORRESPONDING 
CHILD ROWS VALUES(i.e FOREIGN KEY COLUMN) ARE CONVERTING INTO NULLS
IN CHILD TABLE AUTOMATICALLY.
EX:
SQL> CREATE TABLE DEPT3(DEPTNO INT PRIMARY KEY,DNAME VARCHAR2(10));--PARENT

SQL> INSERT INTO DEPT3 VALUES(10,'SALES');
SQL> INSERT INTO DEPT3 VALUES(20,'PRODUCTION');

SQL> CREATE TABLE EMP3(EID INT UNIQUE NOT NULL,
    ENAME VARCHAR2(10),DEPTNO INT REFERENCES
    DEPT3(DEPTNO) ON DELETE SET NULL);---CHILD

SQL> INSERT INTO EMP3 VALUES(1021,'SMITH',10);
SQL> INSERT INTO EMP3 VALUES(1022,'ALLEN',10);
SQL> INSERT INTO EMP3 VALUES(1023,'WARD',20);

TESTING:
SQL> DELETE FROM DEPT3 WHERE DEPTNO=10;
1 row deleted.

DATADICTIONARY / READ ONLY TABLES:
===================================
	- WHENEVER WE ARE INSTALLING ORACLE S/W INTERNALLY SYSTEM IS CREATING  SOME PRE-DEFINED TABLES ARE CALLED AS "DATA DICTIONARIES".
	- DATA DICTIONARIES ARE SAVED THE INFORMATION ABOUT TABLES,CONSTRAINTS,SYNONYMS,VIEWS,INDEXES,SEQUENCES,...............ETC.
	- ON THESE DATA DICTIONARIES WE CAN PERFORM "SELECT" AND "DESC"
COMMANDS ONLY.SO THAT DATADICTIONARIES ARE CALLED AS "READ ONLY TABLES"
IN ORACLE DB.
	- IF WE WANT TO VIEW ALL DATADICTIONARIES IN ORACLE DATABASE THEN WE
FOLLOW THE FOLLOWING SYNTAX IS:

SYNTAX:
========
	SELECT * FROM DICT; ----------(DICT IS MAIN DICTIONARY)

NOTE:
======
	- IF WE WANT TO VIEW COLUMN NAME AND CONSTRAINT NAME OF A PARTICULAR TABLE IN ORACLE DB THEN WE USE A DATADICTIONARY IS CALLED AS
"USER_CONS_COLUMNS".

EX:
SQL> DESC USER_CONS_COLUMNS;
SQL> SELECT COLUMN_NAME,CONSTRAINT_NAME FROM USER_CONS_COLUMNS
          WHERE TABLE_NAME='TEST1';

COLUMN_NAME				CONSTRAINT_NAME
------------------------------------------------	--------------------------------------------------------------------------------
SNO					SYS_C007523
SNAME					SYS_C007524

HOW TO CREATE USER DEFINED CONSTRAINT NAME:
==============================================
SYNTAX:
========
CREATE TABLE <TABLE NAME>
(<COLUMN NAME1> <DATATYPE>[SIZE] CONSTRAINT <UD CONSTRAINT NAME> <CONSTRAINT TYPE>,<COLUMN NAME2> <DATATYPE>[SIZE] CONSTRAINT <UD CONSTRAINT NAME> <CONSTRAINT TYPE>,.........................................);

EX:
SQL> CREATE TABLE TEST6
        (
          EID INT CONSTRAINT PK_EID PRIMARY KEY,
          ENAME VARCHAR2(10) CONSTRAINT  UQ_ENAME UNIQUE
        );
Table created.

SQL> SELECT COLUMN_NAME,CONSTRAINT_NAME FROM USER_CONS_COLUMNS
         WHERE TABLE_NAME='TEST6';

COLUMN_NAME			CONSTRAINT_NAME
------------------------------------------------	--------------------------------------------------------------------------------
EID				PK_EID
ENAME				UQ_ENAME

HOW ADD / APPLY CONSTRAINT ON EXISTING TABLE:
==============================================
SYNTAX:
=======
ALTER TABLE <TN> ADD <CONSTRAINT> <CONSTRAINT KEY NAME> 
<CONSTRAINT TYPE>(COLUMN NAME);

ADDING PRIMARY KEY:
====================
EX:
SQL> CREATE TABLE PARENT(EID INT,ENAME VARCHAR2(10), SAL NUMBER(10));
Table created.

SQL> ALTER TABLE PARENT ADD CONSTRAINT EID_PK PRIMARY KEY(EID);

ADDING UNIQUE,CHECK CONSTRAINT:
=================================
SQL> ALTER TABLE PARENT ADD CONSTRAINT ENAME_UQ UNIQUE(ENAME);
SQL> ALTER TABLE PARENT ADD CONSTRAINT SAL_CHK CHECK(SAL>=10000);

NOTE:
======
	- IF WE WANT TO VIEW A CHECK CONSTRAINT CONDITIONAL VALUE  THEN WE
USE A DATADICTIONARY IS "USER_CONSTRAINTS".

EX:
SQL> DESC USER_CONSTRAINTS;
SQL> SELECT SEARCH_CONDITION FROM USER_CONSTRAINTS
          WHERE TABLE_NAME='PARENT';

SEARCH_CONDITION
--------------------------------------------------------------------------------
SAL>=10000

HOW TO APPLY "NOT NULL" CONSTRAINT:
=====================================
SYNTAX:
=======
ALTER TABLE <TN> MODIFY <COLUMN NAME> <CONSTRAINT> <CONSTRAINT KEY NAME>
NOT NULL;

EX:
SQL> ALTER TABLE PARENT MODIFY ENAME CONSTRAINT ENAME_NN NOT NULL;

HOW TO ADD A FOREIGN KEY CONSTRAINT TO AN EXISTING TABLE:
========================================================
SYNTAX:
=======
ALTER TABLE <TN> ADD CONSTRAINT <CONSTRAINT KEY NAME> 
FOREIGN KEY(COMMON COLUMN OF CHILD TABLE) REFERENCES 
<PARENT TABLE NAME>(COMMON COLUMN OF PARENT TABLE) 
ON DELETE CASCADE / ON DELETE SET NULL;

EX:
SQL> CREATE TABLE CHILD(DNAME VARCHAR2(10),EID INT);
Table created.

SQL> ALTER TABLE CHILD ADD CONSTRAINT EID_FK
  2  FOREIGN KEY(EID) REFERENCES PARENT(EID)
  3  ON DELETE CASCADE;

HOW TO DROP CONSTRAINT FROM AN EXISTING TABLE:
=================================================
SYNTAX:
========
ALTER TABLE <TN> DROP CONSTRAINT <CONSTRAINT KEY NAME>;

TO DROP A PRIMARY KEY:
=======================
CASE-1 : WITHOUT RELATIONSHIP:
==============================
SQL> ALTER TABLE PARENT DROP CONSTRAINT EID_PK;

CASE-2: WITH RELATIONSHIP:
==========================
SQL> ALTER TABLE PARENT DROP CONSTRAINT EID_PK CASCADE;

TO DROP UNIQUE,CHECK,NOT NULL CONSTRAINT:
============================================
EX:
SQL> ALTER TABLE PARENT DROP CONSTRAINT ENAME_UQ;
SQL> ALTER TABLE PARENT DROP CONSTRAINT SAL_CHK;
SQL> ALTER TABLE PARENT DROP CONSTRAINT ENAME_NN;

HOW TO RENAME A CONSTRAINT NAME:
====================================
SYNTAX:
========
ALTER TABLE <TN> RENAME <CONSTRAINT> <OLD CONSTRAINT KEY NAME> TO 
<NEW CONSTRAINT KEY NAME>;

EX:
SQL> CREATE TABLE TEST9(SNO INT PRIMARY KEY);
Table created.

SQL> SELECT COLUMN_NAME,CONSTRAINT_NAME FROM
         USER_CONS_COLUMNS WHERE TABLE_NAME='TEST9';

COLUMN_NAME				CONSTRAINT_NAME
---------------------------------------------		-----------------------------------------------------------------------------------
SNO					SYS_C007566

SQL> ALTER TABLE TEST9 RENAME CONSTRAINT SYS_C007566 TO SNO_PK;

COLUMN_NAME				CONSTRAINT_NAME
---------------------------------------------		-----------------------------------------------------------------------------------
SNO					SNO_PK

HOW TO DISABLE / ENABLE A CONSTRAINT:
======================================
SYNTAX:
=======
ALTER TABLE <TN> DISABLE / ENABLE CONSTRAINT <CONSTRAINT NAME>;

NOTE:
=====
	- BY DEFAULT ALL CONSTRAINTS ARE ENABLE(WORKING) MODE.IF WE WANT 
TO DISABLE A CONSTRAINT TEMPORARLY THEN WE USE "DISABLE" KEYWORD.

DISABLE A CONSTRAINT:
=====================
EX:
SQL> CREATE TABLE TEST10(ENAME VARCHAR2(10),
  2  SAL NUMBER(10) CHECK(SAL>8000));

TESTING:
SQL> INSERT INTO TEST10 VALUES('ALLEN',8001);----ALLOWED

SQL> INSERT INTO TEST10 VALUES('ALLEN',7000);---NOT ALLOWED.
ERROR at line 1:
ORA-02290: check constraint (MYDB4PM.SYS_C007567) violated
	
	- IF WE WANT TO INSERT SALARY WHICH IS LESS THAN TO 8000 THEN WE MUST
DISBALE A CHECK CONSTRAINT TEMPORARLY.

EX:
ALTER TABLE TEST10 DISABLE CONSTRAINT SYS_C007567;

TESTING:
SQL> INSERT INTO TEST10 VALUES('ALLEN',7000);------ALLOWED.

ENABLE A CONSTRAINT:
=====================
EX:
SQL> ALTER TABLE TEST10 ENABLE CONSTRAINT SYS_C007567                          
ERROR at line 1:
ORA-02293: cannot validate (MYDB4PM.SYS_C007567) - check constraint violated

	- TO OVERCOME THE ABOVE PROBLEM AND ENABLE A CHECK CONSTRAINT 
ON SALARY COLUMN THEN WE USE A KEY WORD IS "NOVALIDATE".WHEN WE USE
"NOVALIDATE" KEYWORD ORACLE SERVER IS NOT CHECKING AN EXISTING VALAUES
OF A SALARY COLUMN IN TABLE BUT CHECKING NEWLY INSERTING  DATA/VALUES INTO A SALARY COLUMN.

EX:
SQL> ALTER TABLE TEST10 ENABLE NOVALIDATE CONSTRAINT SYS_C007567;

TESTING:
SQL> INSERT INTO TEST10 VALUES('ADAMS',5500);----NOT ALLOWED
SQL> INSERT INTO TEST10 VALUES('ADAMS',9500);----ALLOWED

DEFAULT CONSTRAINT:
====================
	- IT IS SPECIAL TYPE OF CONSTRAINT WHICH IS USED TO ASSIGN  USER DEFINED
VALUE TO A PARTICULAR COLUMN.

EX:
SQL> CREATE TABLE TEST11(ENAME VARCHAR2(10),SAL NUMBER(10) DEFAULT 8000);
Table created.

TESTING:
SQL> INSERT INTO TEST11 VALUES('ALLEN',25000);
SQL> INSERT INTO TEST11(ENAME)VALUES('SCOTT');

SQL> SELECT * FROM TEST11;

ENAME             	SAL
---------- 		----------
ALLEN           	25000
SCOTT            	8000

HOW TO ADD A DEFAULT VALUE TO AN EXISTING TABLE COLUMN:
=========================================================
SYNTAX:
========
ALTER TABLE <TN> MODIFY <COLUMN NAME> DEFAULT <VALUE>;

EX:
SQL> CREATE TABLE TEST12(SNO INT,SFEE NUMBER(10));
SQL> ALTER TABLE TEST12 MODIFY SFEE DEFAULT 500;

TESTING:
SQL> INSERT INTO TEST12 VALUES(1,15000);
SQL> INSERT INTO TEST12(SNO) VALUES(2);
SQL> SELECT * FROM TEST12;

NOTE:
=====
	TO VIEW A DEFAULT VALUE OF A COLUMN OF PARTICULAR TABLE THEN WE USE 
A DATADICTIONARY IS CALLED AS "USER_TAB_COLUMNS".

EX:
SQL> DESC USER_TAB_COLUMNS;
SQL> SELECT COLUMN_NAME,DATA_DEFAULT FROM USER_TAB_COLUMNS
  2  WHERE TABLE_NAME='TEST12';

COLUMN_NAME		DATA_DEFAULT
------------------------------------------	--------------------------------------
SFEE			500

HOW TO REMOVE DEFAULT VALUE FROM A COLUMN:
=============================================
SYNTAX:
========
ALTER TABLE <TN> MODIFY <COLUMN NAME> DEFAULT <VALUE>;

EX:
SQL> ALTER TABLE TEST12 MODIFY SFEE DEFAULT NULL;

TESTING:
SQL> INSERT INTO TEST12(SNO)VALUES(3);

COLUMN_NAME		DATA_DEFAULT
------------------------------------------	--------------------------------------
SFEE			NULL

==============================================================================











































































